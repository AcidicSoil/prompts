{
	"meta": {
		"generatedAt": "2025-09-24T18:08:15.114Z",
		"tasksAnalyzed": 17,
		"totalTasks": 54,
		"analysisCount": 17,
		"thresholdScore": 5,
		"projectName": "Taskmaster",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 38,
			"taskTitle": "Define Core Data Models and Types",
			"complexityScore": 2,
			"recommendedSubtasks": 2,
			"expansionPrompt": "This task involves creating the foundational TypeScript types for the application. Based on the analysis, a `src/types` directory already exists. Create two subtasks:\n1.  Define `Prompt`, `ToolRegistration`, and `RunRecord` interfaces in a new file `src/types/entities.ts`.\n2.  Define `SandboxConfig` and `ProviderConfig` interfaces in a new file `src/types/config.ts`.\nEnsure all types strictly match the specifications in the task details and are exported for use in other modules.",
			"reasoning": "Codebase analysis shows a `src/types` directory exists, indicating a clear pattern for where these definitions should live. The task is purely declarative, involving the creation of TypeScript interfaces with no complex logic. The complexity is low as it's a matter of transcribing specifications into code."
		},
		{
			"taskId": 39,
			"taskTitle": "Implement Prompt Loader Service",
			"complexityScore": 4,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Create a new service at `src/services/prompt-loader.ts`. This service will scan a directory for markdown files and parse them. Subtasks should be:\n1.  Implement a function to scan the `prompts/` directory and return a list of file paths. Handle the case where the directory doesn't exist.\n2.  Implement a parsing function that takes a file path, reads the content, and uses the `gray-matter` library (already in `package.json`) to parse the frontmatter and content. It should map the parsed data to the `Prompt` type from Task 38.\n3.  Create a main service function that orchestrates the scanning and parsing, aggregates the results, and includes robust error handling for file read errors or parsing failures.",
			"reasoning": "This is a greenfield implementation. While the `gray-matter` library simplifies parsing, the task involves file system I/O, error handling (missing files, malformed frontmatter), and data mapping. A `src/services` directory exists, providing a home for this new module. The complexity is moderate due to the need for robust I/O and error handling logic."
		},
		{
			"taskId": 40,
			"taskTitle": "Implement Prompt Schema Builder",
			"complexityScore": 3,
			"recommendedSubtasks": 2,
			"expansionPrompt": "Create a new utility module, e.g., `src/lib/schema-builder.ts`. This module will contain a pure function that transforms a `Prompt` object into a JSON Schema. Subtasks:\n1.  Implement the core transformation logic that iterates through `prompt.variables` and maps each variable's `type`, `description`, and `default` value to the corresponding JSON Schema properties (`type`, `description`, `default`).\n2.  Enhance the builder to correctly handle the `required` flag by dynamically building the `required` array in the top-level schema object.",
			"reasoning": "This task is a self-contained, pure transformation with no I/O or external dependencies. The logic involves mapping one data structure to another according to specific rules. The complexity is low-to-moderate, focused entirely on the correctness of the transformation logic."
		},
		{
			"taskId": 41,
			"taskTitle": "Set up Basic Mastra MCP Server over Stdio",
			"complexityScore": 1,
			"recommendedSubtasks": 1,
			"expansionPrompt": "Review the existing `src/index.ts` file. Based on the analysis of completed Task 1, the MCP server is already bootstrapped. This task is now about ensuring it's correctly configured. Create one subtask:\n1.  Verify that the `MCPServer` instance in `src/index.ts` is created and started correctly. Add comments to the startup sequence to clarify the initialization process for future integrations.",
			"reasoning": "Codebase analysis confirms that Task 1 ('Project Setup and Server Bootstrap') has already implemented the core of this task. The `src/index.ts` file already instantiates and starts an `MCPServer` over stdio. Therefore, this task is reduced to a verification and documentation step, making its complexity very low."
		},
		{
			"taskId": 42,
			"taskTitle": "Integrate Prompt Loader and Schema Builder with MCP Server",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "This task connects the pieces together in `src/index.ts`. The goal is to load all prompts and register them as tools on startup. Subtasks:\n1.  Modify `src/index.ts` to import and call the Prompt Loader service (Task 39) during the server's startup sequence.\n2.  For each loaded `Prompt`, call the Schema Builder (Task 40) to generate its JSON schema.\n3.  Implement the tool registration logic. For each prompt, call the `server.registerTool()` method with a dynamically generated tool name (`prompts/<slug>`), the generated schema, and a handler function that renders the prompt template with the provided inputs.",
			"reasoning": "This is an integration task that ties together three separate components (Loader, Builder, Server). The complexity comes from orchestrating these parts correctly within the application's startup lifecycle. It requires understanding the `@modelcontextprotocol/sdk`'s `registerTool` API, including how to define the tool's handler function."
		},
		{
			"taskId": 43,
			"taskTitle": "Implement Agent-as-Tool Exposure",
			"complexityScore": 4,
			"recommendedSubtasks": 2,
			"expansionPrompt": "This task involves defining a placeholder agent and registering it as a tool. Subtasks:\n1.  Create a new file `src/agents/planner.ts` to define a simple 'planner' agent. This can be a class or function with a `run` method that takes a question and returns a mock plan. It must have a descriptive docstring.\n2.  In `src/index.ts`, import the planner agent and use the MCP server's `registerTool` method to expose it. The tool name should be `ask_planner`, and its schema should accept a single string input named 'question'. The tool's description should be derived from the agent's docstring.",
			"reasoning": "Codebase analysis shows no existing 'agent' concept, so this is greenfield development. The complexity is moderate, as it requires defining a new application concept (an agent) and then integrating it using the established `registerTool` pattern. The task is simplified by starting with a placeholder implementation."
		},
		{
			"taskId": 44,
			"taskTitle": "Implement Foundational Audit Logging Service",
			"complexityScore": 3,
			"recommendedSubtasks": 2,
			"expansionPrompt": "Create a new service at `src/services/audit-logger.ts` for recording tool executions. Subtasks:\n1.  Define the service structure with a primary function, `logRun(record: RunRecord)`, which takes a `RunRecord` object.\n2.  Implement the logging logic within `logRun`. It should use the existing structured logger from `src/lib/logging.ts` to write the `RunRecord` as a single JSON object to the console. Ensure the log entry has a distinct type, e.g., `{ \"type\": \"audit\", \"record\": { ... } }`.",
			"reasoning": "The task involves creating a new, dedicated service. However, its complexity is reduced because it builds upon two existing pieces: the `RunRecord` type (Task 38) and the pre-existing structured logging utility found in `src/lib/logging.ts`. The core work is creating the service file and calling the existing logger with the correct data structure."
		},
		{
			"taskId": 45,
			"taskTitle": "Implement Initial Policy Engine Stub",
			"complexityScore": 5,
			"recommendedSubtasks": 2,
			"expansionPrompt": "This task establishes the architectural hook for a policy engine. Subtasks:\n1.  Create a new module `src/policy/engine.ts`. Define a `PolicyEngine` class with a method `check(toolCall): Promise<{approved: boolean, reason?: string}>`. Initially, this method should always return `{ approved: true }`.\n2.  Refactor the tool invocation logic in the MCP server to incorporate the policy check. This will likely involve wrapping the `handler` function provided to `server.registerTool` to first call the policy engine's `check` method before executing the original handler.",
			"reasoning": "This is primarily an architectural task. While the initial logic is a simple passthrough, the complexity lies in correctly identifying and modifying the tool invocation pathway to insert this check. This requires a good understanding of the MCP server's execution flow and may involve creating a higher-order function to wrap all tool handlers."
		},
		{
			"taskId": 46,
			"taskTitle": "Implement Sandboxed Filesystem (FS) Integration",
			"complexityScore": 6,
			"recommendedSubtasks": 3,
			"expansionPrompt": "This task involves integrating an external Filesystem MCP server. Subtasks:\n1.  Add the Filesystem MCP server package as a dependency and add a script to `package.json` to run it as a separate process.\n2.  Create a configuration file (e.g., `config/fs-sandbox.json`) using the `SandboxConfig` type (Task 38) to define a default read-only sandbox with a safe root (e.g., a `./workspace` directory).\n3.  Implement logic within the main application to spawn the FS server as a child process, passing the configuration. This will be part of the setup for the Client Orchestrator (Task 48).",
			"reasoning": "This task's complexity comes from managing an external dependency and inter-process communication, rather than writing complex TypeScript logic. It involves configuration, process management (spawning the FS server), and ensuring the two processes can communicate, which is more complex than in-process module integration."
		},
		{
			"taskId": 47,
			"taskTitle": "Implement Read-Only GitHub Integration",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Integrate the GitHub MCP server as a dynamic, read-only toolset. Subtasks:\n1.  Add the GitHub MCP server package as a dependency and add a script to `package.json` to run it.\n2.  Implement configuration logic to load a GitHub token from environment variables (e.g., `GITHUB_TOKEN`).\n3.  Update the Policy Engine (Task 45) to identify tools from the GitHub server (e.g., by a `toolName` prefix) and automatically reject any that are marked with `sideEffects: 'write'`. This enforces the read-only constraint at the application level.",
			"reasoning": "Similar to the FS integration, this involves managing an external process. The complexity is slightly lower if the pattern from Task 46 is reused. A new element of complexity is added by the requirement to enforce read-only access, which requires integration with the Policy Engine (Task 45), making it a cross-cutting concern."
		},
		{
			"taskId": 48,
			"taskTitle": "Implement MCP Client Orchestrator with Dynamic Toolsets",
			"complexityScore": 8,
			"recommendedSubtasks": 4,
			"expansionPrompt": "Create a core client-side orchestrator for managing toolsets. This will be a new major component, likely in `src/orchestration/client.ts`. Subtasks:\n1.  Define the `ClientOrchestrator` class structure. It should initialize by connecting to the main MCP server and fetching its static tool list.\n2.  Implement a method `getToolsetsForTask(taskDescription: string)`. Initially, this can be a stub that returns the static toolset.\n3.  Implement the logic to dynamically attach/detach toolsets. This involves managing connections to multiple MCP servers (e.g., the main server, FS server, GitHub server) and presenting a unified list of available tools to the consumer.\n4.  Develop a placeholder 'agent' that uses the orchestrator to get a list of tools and execute a simple task.",
			"reasoning": "This is a complex, greenfield architectural component. It's the brain that decides which tools an agent gets. The complexity is high due to the need to manage state for multiple client connections, merge tool definitions from different sources, and handle the lifecycle (attach/detach) of these toolsets. It depends on many other components being in place."
		},
		{
			"taskId": 49,
			"taskTitle": "Implement 'intent=write' Guardrail",
			"complexityScore": 4,
			"recommendedSubtasks": 2,
			"expansionPrompt": "Enhance the Policy Engine to enforce a dry-run-by-default mode. Subtasks:\n1.  Modify the `PolicyEngine.check` method in `src/policy/engine.ts`. It needs to receive not just the tool call inputs, but also the tool's definition (specifically the `sideEffects` property).\n2.  Add logic to the `check` method: if `tool.sideEffects === 'write'` and `toolCall.inputs.intent !== 'write'`, then return `{ approved: false, reason: 'This is a write operation. To proceed, you must explicitly set intent=\"write\" in your call.' }`. Otherwise, approve the call.",
			"reasoning": "This task involves adding specific, well-defined logic to an existing component (the Policy Engine from Task 45). The complexity is moderate because it requires modifying the policy engine's interface to give it access to both the tool's static definition and its dynamic inputs, which might require refactoring the hook point."
		},
		{
			"taskId": 50,
			"taskTitle": "Integrate Audit Logging with Tool Invocations",
			"complexityScore": 4,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Wire the Audit Logging service into the tool execution lifecycle. Subtasks:\n1.  Update the tool execution wrapper (likely near the Policy Engine hook) to create a `RunRecord` at the start of a tool call. Populate it with `toolName`, `inputs`, `caller`, and `startedAt`.\n2.  Wrap the actual tool execution in a try/catch/finally block. On success, capture the `outputsRef` and `status: 'success'`. On error, capture the error and `status: 'error'`. \n3.  In the `finally` block, calculate `latencyMs` and call the `auditLogger.logRun()` method with the completed `RunRecord` object.",
			"reasoning": "This is an integration task. The complexity comes from correctly wrapping the tool execution to capture all states (start, success, error) and timings. It needs to be placed in the correct part of the execution pipeline, likely alongside the Policy Engine check, to ensure every call is logged. The Audit Logging service itself is already defined (Task 44)."
		},
		{
			"taskId": 51,
			"taskTitle": "Implement Search and Fetch Integration",
			"complexityScore": 3,
			"recommendedSubtasks": 2,
			"expansionPrompt": "Integrate the Tavily MCP server as a dynamic toolset, following the established pattern. Subtasks:\n1.  Add the Tavily MCP server as a dependency and configure its startup, including API key management via environment variables.\n2.  Update the Client Orchestrator (Task 48) to recognize when a task requires web search and dynamically attach the Tavily toolset.",
			"reasoning": "By this point, the pattern for integrating external MCP servers (from Tasks 46 and 47) and managing them with the orchestrator (Task 48) should be well-established. This task is about applying that pattern to a new tool. The complexity is therefore lower than the initial integrations."
		},
		{
			"taskId": 52,
			"taskTitle": "Create Pluggable Provider Abstraction Layer",
			"complexityScore": 3,
			"recommendedSubtasks": 2,
			"expansionPrompt": "Create a common interface for inference providers. Subtasks:\n1.  Create a new directory `src/providers`. In `src/providers/types.ts`, define a `Provider` interface with methods like `chatCompletion(request): Promise<Response>` and `createEmbedding(request): Promise<Response>`.\n2.  Create a factory function or manager class in `src/providers/manager.ts` that can instantiate and return a specific provider implementation based on a `ProviderConfig` object.",
			"reasoning": "This is a foundational, greenfield architecture task. Codebase analysis shows no existing provider code to refactor, which simplifies the work. The complexity is low-to-moderate and involves defining clean interfaces and a factory pattern, which is standard software design."
		},
		{
			"taskId": 53,
			"title": "Integrate Nexa SDK as a Local Provider for Chat",
			"complexityScore": 4,
			"recommendedSubtasks": 2,
			"expansionPrompt": "Implement the `Provider` interface for a local Nexa server. Subtasks:\n1.  Create a new file `src/providers/nexa.ts`. Implement a `NexaProvider` class that conforms to the `Provider` interface from Task 52.\n2.  Implement the `chatCompletion` method within `NexaProvider`. It should use `fetch` to make an HTTP POST request to the configured Nexa base URL, passing the arguments in an OpenAI-compatible format. Handle API responses and errors.",
			"reasoning": "This task is a concrete implementation of an interface defined in Task 52. The complexity is moderate, as it involves interacting with an external service over HTTP, including request/response mapping and error handling. It's a standard implementation task, not a complex architectural one."
		},
		{
			"taskId": 54,
			"taskTitle": "Implement PII Redaction in Audit Logs",
			"complexityScore": 2,
			"recommendedSubtasks": 1,
			"expansionPrompt": "Integrate the existing redaction utility into the audit logging flow. Create one subtask:\n1.  In the `AuditLogger` service (`src/services/audit-logger.ts`), before writing the log, pass the `RunRecord` object through the `redact` function that already exists in `src/lib/logging.ts`. Ensure the redaction is applied to both the `inputs` and `outputsRef` fields of the record.",
			"reasoning": "Codebase analysis confirmed that a `redact` utility function already exists in `src/lib/logging.ts` as a result of Task 2. This task is therefore a simple integration of an existing utility into an existing service. The complexity is very low, involving only a single function call at the correct location."
		}
	]
}